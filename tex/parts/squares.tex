\section{Абелевы квадраты}
% Мы расскажем в этой части как искать число бла-бла-бла.
% Так же мы провели эксперименты - правда ли n^1.8, и имеет ли вообще смысл такой алгоритм на практике

\subsection{Обзор алгоритма решения 3SUM+}

\begin{problem}
$3SUM^+$: дано три множества $A, B, C$, нужно найти три числа $a \in A, b \in B, c \in C$ такие, что $a+b=c$.
\end{problem}


Кратко рассмотрим алгоритм, предложенный в \cite{2}. 

В этой статье предложено решение задачи $3SUM^+$ для монотонных линейно ограниченных множеств. Оно основано на использовании \textit{BSG-теоремы} и быстрого преобразования фурье для выделения набора пар подмножеств с относительно небольшой декартовой суммой, достаточно плотно покрывающих полную декартову сумму $A+B$.

Предложенный алгоритм является довольно большим продвижением в изучении задачи $3SUM^+$, являясь первым строго субквадратичным алгоритмом для задач, основанных на ограниченной монотонной (min,+) свертке.

В алгоритме есть большое пространство для дальнейшего исследования. Так, авторами поставлена задача для улучшения детерменированной версии алгоритма с целью от избавления от перемножения матриц с предположением, что можно так же использовать преобразование фурье. Кроме того, поиск применений мощных методов аддитивной комбинаторики в задачах дискретной математики выглядит очень перспективной областью исследования.

\subsection{Поиск числа Абелевых подквадратов}
\begin{problem}
Дана строка $s=s_0s_1 \cdots s_{n-1}$ из символов двух типов, $a$ и $b$. Нужно найти количество различных ее подстрок $s_{i \cdots j}$, являющихся Абелевыми квадратами.
\end{problem}

\subsubsection{Сведение к 3SUM+}
Задачу о поиске числа Абелевых подквадратов бинарной можно свести к задаче 3SUM+.

Пусть строка . Рассмотрим следующие множества:

\begin{equation}
A = \{ (cnt_a(i), cnt_b(i)) | 0 \le i \le n \},
\end{equation}

\begin{equation}
B = \{ (cnt_a(i), cnt_b(i)) | 0 \le i \le n \},
\end{equation}

\begin{equation}
C = \{ (2cnt_a(i), 2cnt_b(i)) | 0 \le i \le n \},
\end{equation}


где $cnt_x(i)$~--- количество символов типа $c$ на префиксе строки $s$ длины $i$. Мотивация для этого сведения в том, что мы хотим, чтобы по обоим символам количество вхождений этого символа в первой половине строки было равно количеству вхождений во второй. Если рассматривать подстроку $[i; j)$, середина которой $k={i+j} \over 2$, то должно быть выполнено $cnt_a(k)-cnt_a(i)=cnt_a(j)-cnt_a(k)$ и $cnt_b(k)-cnt_b(i)=cnt_b(j)-cnt_b(k)$, или $cnt_x(i)+cnt_x(j)=2cnt_x(k)$. Поскольку $cnt_a(i)+cnt_b(i)=i$, становится понятно, что число абелевых подквадратов можно найти по формуле 

\begin{equation}
(\#3SUM^+(A, B, C) - (n+1)) / 2,
\end{equation}

где $n+1$ приходится вычитать, потому что нам неинтересны решения длины 0, а делить на два, потому что каждая подстрока будет посчитана дважды, с $i<j$ и $i>j$.

Поскольку лучшее известное решение задачи $3SUM^+$ для монотонных ограниченных $\mathcal{O}(n)$, работает за $\mathcal{O}(n^{1.86})$, а сведение работает за линию, получаем такое же решение задачи о количестве Абелевых подквадратов.

На самом деле, предполагая, что средний компьютер выполняет порядка $10^9$ операций в секунду, и предположив, что мы будем проверять решение на ограничениях порядка $n=10^5$, асимптотическое ускорение в $n^0.14$ переводя в числа ускоряет всего в ${10^5}^{0.14} \approx 5$ раз, что может оказаться незаметным, а вспоминая о большой константе алгоритма и нескольких логарифмах можно предположить о его практической неэффективности. Все же, представляет интерес для изучения работа алгоритма на специфичных тестах или в среднем случае, вдруг он работает достаточно быстро с какой-то стороны.
% Здесь рассказываешь в деталях как же ты ищешь

%\subsection{Реализация алгоритма}
% Тут можно описать все детали и проблемы, с которыми ты столкнулся в реализации.
% Далее, рассказать какие ты тесты генерировал И нарисовать красивый графичек.
