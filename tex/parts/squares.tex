\section{Абелевы квадраты}
% Мы расскажем в этой части как искать число бла-бла-бла.
% Так же мы провели эксперименты - правда ли n^1.8, и имеет ли вообще смысл такой алгоритм на практике

\subsection{Поиск числа Абелевых подквадратов}

\subsubsection{Сведение к 3SUM+}
Задачу о поиске числа Абелевых подквадратов в бинарной строке можно свести к задаче $3SUM^+$.

Пусть дана строка $s=s_0s_1 \ldots s_{n-1}$. Рассмотрим следующие множества:

\begin{equation}
A = \{ (cnt_{c_1}(i), cnt_{c_2}(i))\ |\ 0 \le i \le n \},
\end{equation}

\begin{equation}
B = \{ (cnt_{c_1}(i), cnt_{c_2}(i))\ |\ 0 \le i \le n \},
\end{equation}

\begin{equation}
C = \{ (2 \cdot cnt_{c_1}(i), 2 \cdot cnt_{c_2}(i))\ |\ 0 \le i \le n \},
\end{equation}


где $cnt_x(i)$~--- число символов типа $x$ на префиксе длины $i$ строки $s$. Мотивация для этого сведения в том, что для Абелево подквадрата мы хотим, чтобы по обоим символам число вхождений этого символа в первой половине подстроки было равно числу вхождений во второй. Если рассматривать подстроку $[i; j)$, середина которой $k={{i+j} \over 2}$, то должно быть выполнено $cnt_{c_1}(k)-cnt_{c_1}(i)=cnt_{c_1}(j)-cnt_{c_1}(k)$ и $cnt_{c_2}(k)-cnt_{c_2}(i)=cnt_{c_2}(j)-cnt_{c_2}(k)$, или $cnt_x(i)+cnt_x(j)=2cnt_x(k)$. Поскольку $cnt_{c_1}(i)+cnt_{c_2}(i)=i$, становится понятно, что число абелевых подквадратов можно найти по формуле 

\begin{equation}
(\#3SUM^+(A, B, C) - (n+1))\ /\ 2,
\end{equation}

где $n+1$ приходится вычитать, потому что нам неинтересны решения длины 0, а делить на два, потому что каждая подстрока будет посчитана дважды, с $i<j$ и $i>j$.

Поскольку лучшее известное решение задачи $3SUM^+$ для монотонных ограниченных множеств с элементами $\mathcal{O}(n)$, работает за $\mathcal{O}(n^{1.86})$, а наше сведение работает за линию, получаем решение задачи о количестве Абелевых подквадратов за ту же асимптотику.

На самом деле, предполагая, что средний компьютер выполняет порядка $10^9$ операций в секунду, и предположив, что мы будем проверять решение на ограничениях порядка $n=10^5$, асимптотическое ускорение в $n^{0.14}$, переводя в числа, ускоряет всего в ${(10^5)}^{0.14} \approx 5$ раз, что может оказаться незаметным, а вспоминая о большой константе алгоритма и нескольких логарифмах можно предположить о его практической неэффективности. Все же, представляет интерес для изучения работа алгоритма на специфичных тестах или в среднем случае, вдруг он работает достаточно быстро с какой-то стороны. 

Результаты экспериментальных запусков мы приведем в главе 3.
% Здесь рассказываешь в деталях как же ты ищешь

%\subsection{Реализация алгоритма}
% Тут можно описать все детали и проблемы, с которыми ты столкнулся в реализации.
% Далее, рассказать какие ты тесты генерировал И нарисовать красивый графичек.
