\section{Предыдущие результаты}
\subsection{Наибольшая общая Абелева подстрока}
По постановке задача о поиске наибольшей общей Абелевой подстроке очень похожа на поиск наидлиннейшей общей подстроки~--- очень важную задачу, исследовавшуюся в 70-е года прошлого века. В частности, суффиксное дерево было разработано в процессе работы над несколькими задачами, одной из которых являлся линейный поиск наидлиннейшей общей подстроки.

Задача поиска наибольшей общей Абелевой подстроки (\textit{LCAS}) была сформулирована в 2013 году на семинаре StringMasters. Там она была поставлена как открытая задача. 

После этого в 2015 году A.Attabi et al в \cite{1} предложили два алгоритма решения этой задачи. 

Первый алгоритм решает задачу поиска НОАП за $\langle \mathcal{O}(n^2 \sigma), \mathcal{O}(n \sigma) \rangle$. В этом алгоритме автор предлагает для каждой длины посчитать для обеих строк векторы Парея для всех подстрок за $\langle \mathcal{O}(n \sigma), \mathcal{O}(n \sigma) \rangle$, отсортировать их сортировкой подсчетом, и после этого двумя указателями проверить, есть ли две Абелево эквивалентные подстроки.

Второй алгоритм решает задачу поиска НОАП для строки на бинарном алфавите. Он использует два факта: для фиксированной длины строки достаточно сравнивать лишь количество одного из символов $c_1$, и что если у строки есть подстрока длины $l$ с $x$ символов $c_1$, и подстрока длины $l$ с $y$ символов $c_1$, то найдется и подстрока с $z$ символов $c_1$ для любого $x \le z \le y$. Используя эти факты, в алгоритме для каждой длины $l$ у обеих строк считается максимальное и минимальное количество символов $c_1$, которые могут быть у подстроки длины $l$. Если эти отрезки для длины $l$ у строк пересекаются, то $l$~--- кандидат на НОАП. На алгоритм подсчета этих отрезков за $\mathcal{O}(n^2 / \log n)$ авторы ссылаются как на уже известный.

%Субквадратичный алгоритм для случая $\sigma=2$, работающий за $\mathcal{O}(n^2/\log n)$ времени, и решение общего случая за $\mathcal{O}(n^2\sigma)$ времени и $\mathcal{O}(n\sigma)$ памяти.

В 2016 году на конференции SPIRE S.Grabowski et al \cite{4} улучшили алгоритм 2015 года, уменьшив требование памяти до $\mathcal{O}(n)$, и алгоритм, решающий задачу для случая алфавитов большого размера, работающий за $(\mathcal{O}(n^2 \log^2 n \log^* n), \mathcal{O}(n \log^2 n))$ времени и памяти. 

Первый результат, улучшение памяти алгорита A.Attabi et al основано на двух оптимизациях: во-первых, во время сортировки не хранится все векторы Парея, а на каждой из $\sigma$ итераций количество вхождений очередного символа вычисляется заново. Во-вторых, для того, чтобы все еще можно было сравнивать векторы Парея, явно хранятся векторы Парея для всех позиций, кратных $\sigma$, т.е. для $s_0 \ldots s_{l-1}$, $s_\sigma \ldots s_{\sigma + l - 1}$, и так далее. Для сравнения векторов Парея двух произвольных подстрок, нужно взять ближайший посчитанный вектор Парея, изменить в нем $\mathcal{O}(\sigma)$ элементов, так что сравнение все еще работает за такое же время.

%TODO расписать больше мотивации? всякая биоинформатика

Сравнительное времени работы этих алгоритмов можно увидеть в таблице 1.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Год & Авторы & Время & Память \\
\hline
2015 & A. Alattabi et al & $\mathcal{O}(n^2 \sigma)$ & $\mathcal{O}(n \sigma)$ \\
\hline
2016 & S. Grabowski et al & $\mathcal{O}(n^2 \sigma)$ & $\mathcal{O}(n)$ \\
\hline
2016 & S. Grabowski et al & $\mathcal{O}(n^2 \log^2 n \log^* n)$ & $\mathcal{O}(n \log^2 n)$ \\
\hline
2017 & Данная работа & $\mathcal{O}(n^2 \log \sigma)$ & $\mathcal{O}(n)$ \\
\hline
\end{tabular}
\end{center}
\caption{Существующие детерменированные алгоритмы поиска НОАП}
\end{table}

Кроме того, нельзя не упомянуть о недетерменированных версиях решения этой задачи. Я не нашел публикаций, посвященных этому алгоритму, так что назовем это фольклором.

Определим полиномиальный хеш последовательности $s=s_0s_1\ldots s_{|s|-1}$ как $h(s)=(\sum\limits_{i=0}^{|s|-1} s_i \cdot p^i) \mod{m}$ для каких-то параметров $p$ и $m$.

Фиксировав длину $l$, можно скользящим окном посчитать полиномиальный хеш последовательности $\mathcal{P}(s_i\ldots s_{i+l-1})$ для всех подстрок длины $l$. 

Посчитав полиномиальные хеши всех подстрок обеих строк, можно проверить, есть ли совпадающие, используя хешмап. В случае совпадения хешей нужно проверить подстроки на Абелеву эквивалентность отдельно, поскольку совпадение полиномиальных хешей еще не гарантирует эквивалентность строк, но ложное совпадение очень маловероятно.

Оценить матожидание времени работы такого алгоритма довольно сложно, но на практике он работает очень быстро, и есть все основания полагать, что можно доказать его временную оценку в $\mathcal{O}(n^2)$. На этот алгоритм была предложена задача на интернет-олимпиаду для школьников в 2015 году \cite{6}.

\subsection{Наибольший Абелев подквадрат и количество Абелевых подквадратов строки}
Задачи о нахождении наидлиннейшего Абелево подквадрата и их количества были поставлены в 2016 году, с указанием метода, опубликованным в том же году, позволяющего находить большое количество Абелевых характеристик за $\mathcal{O}(n^2 / \log^2 n)$ \cite{5}.

Так же недавно был опубликован новый алгоритм для решения задачи \textit{3-SUM} используя методы аддитивной комбинаторики, решающий частный случай задачи значительно быстрее, чем за квадратичное время~--- за $\mathcal{O}(n^{1.86})$. Так же они показали, как отвечать на запросы \textit{histogram queries} за $\mathcal{O}(1)$ после предподсчета за $\mathcal{O}(n^{1.86})$.