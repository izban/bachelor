\section{Предыдущие результаты}
\subsection{Наибольшая общая Абелева подстрока}
Постановка задачи о поиске наибольшей общей Абелевой подстроке схожа с задачей поиска наидлиннейшей общей подстроки~--- очень важной задачи, исследовавшейся в 70-е года прошлого века. В частности, суффиксное дерево и линейный алгоритм его построения были разработаны в процессе работы над несколькими задачами, одной из которых являлся линейный поиск наидлиннейшей общей подстроки.

Задача поиска наибольшей общей Абелевой подстроки (\textit{LCAS}) была сформулирована в 2013 году на семинаре StringMasters. Там она была поставлена как открытая задача. 

После этого в 2015 году A.Attabi et al \cite{1} предложили два алгоритма решения этой задачи. 

Первый алгоритм решает задачу поиска НОАП за $\langle \mathcal{O}(n^2 \sigma), \mathcal{O}(n \sigma) \rangle$. В этом алгоритме авторы предлагают для каждой длины посчитать для обеих строк векторы Парея всех подстрок такой длины за $\langle \mathcal{O}(n \sigma), \mathcal{O}(n \sigma) \rangle$, отсортировать их сортировкой подсчетом, и после этого двумя указателями проверить, есть ли две Абелево эквивалентные подстроки.

Второй алгоритм решает задачу поиска НОАП для строк на бинарном алфавите. Он использует два факта: что для фиксированной длины подстроки достаточно сравнивать лишь количество одного из символов $c_1$, и что если у строки есть подстрока длины $l$ содержащая $x$ символов $c_1$, и подстрока длины $l$ содержащая $y$ символов $c_1$, то найдется и подстрока содержащая $z$ символов $c_1$ для любого $x \le z \le y$. Используя два этих факта, в алгоритме для обеих строк считается максимальное и минимальное количество символов $c_1$, которые могут быть у подстроки длины $l$ для каждой длины. Если эти отрезки для длины $l$ у строк пересекаются, то $l$~--- кандидат на НОАП. На алгоритм подсчета этих отрезков за $\mathcal{O}(n^2 / \log n)$ авторы ссылаются как на уже известный. Один из вариантов это сделать~--- применить метод четырех русских, предподсчитав матрицу размера $\log n \over 2$ на $\log n \over 2$, в которой содержится изменение количества единиц и максимальное число единиц, полученное на префиксе, если отрезать такие первые $\log n \over 2$ символов и дописать такие последние $\log n \over 2$ символов. Прыжков получится $2 \cdot n / \log n$, что и дает искомую асимптотику в $n^2 / \log n$.

В 2016 году на конференции SPIRE S.Grabowski et al \cite{4} улучшили алгоритм из \cite{1} 2015 года, уменьшив требование памяти до $\mathcal{O}(n)$, и предложили алгоритм, решающий задачу для случая алфавитов большого размера, работающий за $\langle \mathcal{O}(n^2 \log^2 n \log^* n), \mathcal{O}(n \log^2 n) \rangle$ времени и памяти. 

Первый результат, улучшение памяти алгоритма A.Attabi et al основано на двух оптимизациях. Во-первых, во время сортировки не хранятся все векторы Парея, а на каждой из $\sigma$ итераций количество вхождений очередного символа вычисляется заново. Во-вторых, для того, чтобы все еще можно было сравнивать векторы Парея, явно хранятся векторы Парея для всех позиций, кратных $\sigma$, т.е. для подстрок $s_0 \ldots s_{l-1}$, $s_\sigma \ldots s_{\sigma + l - 1}$, и так далее. Для сравнения векторов Парея двух произвольных подстрок, нужно взять ближайший посчитанный вектор Парея и изменить в нем $\mathcal{O}(\sigma)$ элементов, таким образом сравнение все еще работает за $\mathcal{O}(\sigma)$.

Второй алгоритм использует технику для поддержания изменяющегося множества строк с операциями split, join и equality testing, опубликованной в \cite{9}.

%TODO расписать больше мотивации? всякая биоинформатика

Сравнительное времени работы этих алгоритмов можно увидеть в таблице 1.

\begin{table}[H]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Год & Авторы & Время & Память \\
\hline
2015 & A. Alattabi et al & $\mathcal{O}(n^2 \sigma)$ & $\mathcal{O}(n \sigma)$ \\
\hline
2016 & S. Grabowski et al & $\mathcal{O}(n^2 \sigma)$ & $\mathcal{O}(n)$ \\
\hline
2016 & S. Grabowski et al & $\mathcal{O}(n^2 \log^2 n \log^* n)$ & $\mathcal{O}(n \log^2 n)$ \\
\hline
2017 & Данная работа & $\mathcal{O}(n^2 \log \sigma)$ & $\mathcal{O}(n)$ \\
\hline
\end{tabular}
\end{center}
\caption{Существующие детерминированные алгоритмы поиска НОАП}
\end{table}

Кроме того, нельзя не упомянуть о недетерминированных версиях решения этой задачи. Публикации, посвященные этому алгоритму не были найдены, так что назовем это фольклором.

Определим полиномиальный хеш последовательности $s=s_0s_1\ldots s_{|s|-1}$ как $h(s)=(\sum\limits_{i=0}^{|s|-1} s_i \cdot p^i) \mod{m}$ для выбранных параметров $p$ и $m$, где в качестве $m$ обычно берется простое число, а в качестве $p$ произвольное.

Фиксировав длину $l$, можно скользящим окном посчитать полиномиальный хеш последовательностей $\mathcal{P}(s_i\ldots s_{i+l-1})$ для всех подстрок длины $l$, начинающихся в $i \in [0, n-l]$, за $\mathcal{O}(n)$ времени.

Посчитав полиномиальные хеши векторов Парея всех подстрок обеих строк, можно проверить, есть ли совпадающие, используя хешмап. В случае совпадения хешей нужно произвести допольнительную проверку подстрок на Абелеву эквивалентность, поскольку совпадение полиномиальных хешей еще не гарантирует эквивалентность строк, хотя коллизия хешей векторов Парея очень маловероятна.

Оценить математическое ожидание времени работы такого алгоритма довольно сложно, но на практике он работает очень быстро, и есть все основания полагать, что математическое ожидание его времени работы $\mathcal{O}(n^2)$. На этот алгоритм была предложена задача на интернет-олимпиаду ИТМО в 2015 году \cite{6}.

\subsection{Наибольший Абелев подквадрат и количество Абелевых подквадратов строки}
Задачи о нахождении наидлиннейшего Абелево подквадрата и их количества были поставлены в 2016 году, с указанием на метод, опубликованный в том же году, позволяющий решать некоторые задачи, связанные с Абелевой эквивалетностью, за субквадратичное время \cite{5}.

\begin{definition}
%Строка $t$ является Абелевым периодом строки $s$, если $s$ представимо как конкатенация набора строк $t_1 t_2 \ldots t_k$, где для всех $i$ верно, что каждое $t_i$ Абелево эквивалентно $t$.
Подстрока $s_i s_{i+1} \ldots s_{i+k-1}$ является Абелевым периодом строки $s$, если существует такое $j$, что $s_i s_{i+1} \ldots s_{i+k-1} \equiv s_{i+k} s_{i+k+1} \cdots s_{i+2k-1} \equiv \ldots \equiv s_{i+(j-1)k} s_{i+(j-1)k+1} \ldots s_{i+jk-1}$, и как $s_0 \ldots s_{i-1}$, так и $s_{i+jk} \ldots s_{|s|-1}$ являются Абелевыми подстроками подстроки $s_i s_{i+1} \ldots s_{i+k-1}$.
\end{definition}

\begin{definition}
Строка $t$ является Абелевым бордером строки $s$, если префикс и суффикс длины $|t|$ строки $s$ Абелево эквивалентны $t$.
\end{definition}

\begin{definition}
Абелев бордер $t$ является Абелевым покрытием строки $s$, если Абелевы вхождения строки $t$ в $s$ покрывают полностью всю строку $s$.
\end{definition}

Авторы этой статьи предложили алгоритмы поиска длиннейшего/кратчайшего Абелевого подквадрата за $\mathcal{O}(n^2 / \log^2 n)$, поиска кратчайшего Абелевого периода за $\mathcal{O}(n^2 / \sqrt{\log n})$, поиска Абелевых бордеров строки за $\mathcal{O}(n^2 / \log^2 n)$ и поиска всех Абелевых покрытий строки за $\mathcal{O}(n^2 / \log n)$.

Так же недавно был опубликован новый алгоритм для решения задачи $3SUM^+$, используя методы аддитивной комбинаторики, решающий частный случай задачи значительно быстрее, чем за квадратичное время~--- за $\mathcal{O}(n^{1.86})$. С помощью этого алгоритма они показали, как отвечать на запросы \textit{histogram queries} за $\mathcal{O}(1)$ после предподсчета за $\mathcal{O}(n^{1.86})$.

\subsection{Обзор алгоритма решения 3SUM+}

Кратко рассмотрим алгоритм решения задачи $3SUM^+$, предложенный в \cite{2}. 

В упомянутой статье было предложено решение задачи $3SUM^+$ для монотонных линейно ограниченных множеств. Ограничимся случаем, когда множества $A, B, C$ состоят из точек в двумерном пространстве.

Сначала вводится функция $cell(a)$~--- все точки разбиваются по принадлежности к клеткам со стороной длины $l$, получая $(n/l)^2$ различных клеток, в которых могут находиться исходные точки. Кроме того, точки нормализуются так, что для любых точек $a \in A, b \in B$ верно, что $cell(a+b)=cell(a)+cell(b)$, это достигается путем решения четырех подзадач подзадач.

Ко множеству непустых клеток $A^* = \{cell(a)\ :\ a \in A\}$,  $B^* = \{cell(b)\ :\ b \in B\}$, $C^* = \{cell(c)\ :\ c \in C\}$ применяется \textit{BSG Corollary}, получая набор множеств $A_1^*, \ldots, A_k^*, B_1^*, \ldots, B_k^*$ и остаток $R^*$.

Для каждой клетки остатка $(a^*, b^*) \in R^*$ задача решается рекурсивно для множеств $\{a \in A\ :\ cell(a)=a^*\}$, $\{b \in B\ :\ cell(b)=b^*\}$ и $\{c \in C\ :\ cell(c)=a^*+b^*\}$.

Затем, для каждого $i=1, \ldots, k$ применяется алгоритм, работающий на основе быстрого преобразования Фурье, чтобы получить все $\{a \in A\ :\ cell(a) \in A_i^*\}+\{b \in B\ :\ cell(b) \in B_i^*\}$, которые содержатся в надмножестве $T_i=\{s \in \mathcal{Z}^d\ :\ cell(s) \in A_i^* + B_i^*\}$.

Основная идея алгоритма в том, что после кластеризации точек, используя \textit{BSG Corollary} можно довольно быстро выделить набор пар множеств с малой декартовой суммой, которые своей суммой плотно покрывают кластеризованное точек, оставляя небольшой остаток. Для каждой непокрытой пары из остатка задача решается рекурсивно, а для каждой пары множеств, из-за того, что их декартова сумма невелика, используя быстрое преобразование Фурье, она считается быстрее, чем за квадрат.

Предложенный алгоритм является довольно большим продвижением в изучении задачи $3SUM^+$, являясь первым строго субквадратичным ($\mathcal{O}(n^\alpha), \alpha < 2$) алгоритмом для задач, основанных на ограниченной монотонной (min,+) свертке.

В алгоритме есть пространство для дальнейшего исследования. Так, авторами поставлена задача для улучшения детерменированной версии алгоритма с целью избавления от перемножения матриц с предположением, что можно так же использовать преобразование Фурье. Помимо этого, поиск применений мощных методов аддитивной комбинаторики в задачах дискретной математики выглядит очень перспективной областью исследования.
