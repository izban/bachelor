\chapter{Практические результаты}
\section{Наибольшая общая Абелева подстрока}
\subsection{Случай бинарного алфавита}

Первое, что хочется сделать~--- посмотреть, как себя ведет на практике матожидание наибольшей общей Абелевой подстроки двух случайных бинарных строк. 

Я выполнил $10^4$ запусков поиска НОАП для различных значений $n$ до $10^4$. Такого количества запусков оказалось вполне достаточно, чтобы среднее значение НОАП стабилизировалось. Полученный результат можно увидеть на рисунке 2.

\begin{figure}[h]
\center{\includegraphics[scale=1]{pics/avlcas.png}}
\caption{зависимость матожидания НОАП от длин строк}
\end{figure}

Видно, что функция ведет себя очень точно как прямая $y=0.83x$, что подтверждает полученные теоретические линейные оценки как сверху, так и снизу.

%\subsection{Общий случай}
%Пусто? Ну я канеш могу закодить то что я придумал но не оч хочется(((

\section{Количество Абелевых подквадратов}

Реализованный алгоритм решения $3SUM^+$ был протестирован на строке из одинаковых символов, и на наборе пар случайных бинарных строк. На практике он показал себя достаточно плохо, в несколько раз проигрывая наивному решению за $\mathcal{O}(n^2)$.

\begin{figure}[h]
\center{\includegraphics[scale=1]{pics/4.png}}
\caption{зависимость средней времени работы на унарной строке от ее длины}
\end{figure}

На рисунке 3 можно увидеть зависимость времени работы решения в секундах от $n$~--- длины строк, данных на вход, на тесте со строками из одинаковых символов. График действительно довольно похож на $n^{1.86}$, но из-за нескольких логарифмов в асимптотике растет несколько быстрее. 

\begin{figure}[h]
\center{\includegraphics[scale=1]{pics/5.png}}
\caption{зависимость средней времени работы на случайной строке от ее длины}
\end{figure}

На рисунке 4 можно увидеть зависимость времени работы решения в секундах от $n$~--- длины строк, данных на вход, на тесте со случайными строками из двух различных символов.

Время работы алгоритма довольно сильно меняется как от запуска к запуску из-за разных тестов, так и от различных значений $n$, так как различные ветки программы выполняются с разными вероятностями и работают разное время~--- не приходится удивляться некоторому увеличению производительности при увеличении $n$.
